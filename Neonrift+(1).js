(() => {
  // Expose create() globally (UNCHANGED contract with your launcher)
  window.create = function create(prefillUrl = "") {
    const win = window.open();
    if (!win) return alert("Popup blocked. Allow popups, then try again.");

    win.document.body.style.margin = "0";
    win.document.body.style.height = "100vh";
    win.document.body.style.background = "#000";

    const iframe = win.document.createElement("iframe");
    iframe.style.cssText = "border:none;width:100%;height:100%;margin:0";
    iframe.allow = "fullscreen; gamepad; autoplay";
    iframe.referrerPolicy = "no-referrer";
    iframe.src = "about:blank";
    win.document.body.appendChild(iframe);

    // =======================
    // GAME HTML (restructured)
    // =======================
    const GAME_LINES = [
      "<!doctype html><html><head>",
      '<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>',
      "<title>Neon Rift — Cyberpunk Split-Screen</title>",
      "<style>",
      "html,body{margin:0;height:100%;background:#04040a;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}",
      "canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}",
      ".hud{position:fixed;left:12px;top:10px;color:#cfd3ffcc;font-size:12px;line-height:1.25;text-shadow:0 0 10px #6a74ff55;user-select:none;pointer-events:none}",
      ".hudR{position:fixed;right:12px;top:10px;color:#e8e9ffcc;font-size:12px;line-height:1.25;text-shadow:0 0 10px #ff6ad855;user-select:none;pointer-events:none;text-align:right}",
      ".tip{opacity:.75}",
      "</style></head><body>",
      '<canvas id="c"></canvas>',
      '<div class="hud"><b>NEON RIFT</b> — Cyberpunk Split-Screen Roguelite<br>',
      '<span class="tip">P1: WASD + Mouse (aim) + LMB shoot + Shift dash + Q hack pulse</span><br>',
      '<span class="tip">P2: Arrows move + Enter shoot + Right Shift dash + / hack pulse (auto-aim)</span><br>',
      '<span class="tip">P pause • R restart • F fullscreen</span></div>',
      '<div class="hudR" id="toast"></div>',
      "<script>",
      "(function(){",
      "  'use strict';",
      "  // -------- Utilities --------",
      "  const TAU=Math.PI*2;",
      "  const clamp=(v,a,b)=>v<a?a:v>b?b:v;",
      "  const lerp=(a,b,t)=>a+(b-a)*t;",
      "  const hypot=Math.hypot;",
      "  const now=()=>performance.now();",
      "  const rint=(a)=>((Math.random()*a)|0);",
      "  const pick=(arr)=>arr[(Math.random()*arr.length)|0];",
      "  function hashSeed(s){let h=2166136261>>>0;for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619)>>>0;}return h>>>0;}",
      "  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;}}",
      "  // -------- Canvas / Pixel buffer --------",
      "  const c=document.getElementById('c');",
      "  const x=c.getContext('2d',{alpha:false});",
      "  let W=0,H=0,DPR=1;",
      "  // Offscreen pixel buffer (low-res) we scale up",
      "  const pc=document.createElement('canvas');",
      "  const px=pc.getContext('2d',{alpha:false});",
      "  function rs(){",
      "    DPR=Math.max(1,Math.min(2.25,devicePixelRatio||1));",
      "    W=(innerWidth*DPR)|0;H=(innerHeight*DPR)|0;",
      "    c.width=W;c.height=H;",
      "    // pick pixel scale to look chunky but readable",
      "    const scaleTarget=Math.max(2,Math.min(4,Math.round((Math.min(innerWidth,innerHeight)/240))));",
      "    PIX_SCALE=scaleTarget|0;",
      "    // low res buffer",
      "    pc.width=(innerWidth/PIX_SCALE)|0;",
      "    pc.height=(innerHeight/PIX_SCALE)|0;",
      "  }",
      "  let PIX_SCALE=3;",
      "  addEventListener('resize',rs,{passive:true});rs();",
      "  // -------- Input --------",
      "  const keys=new Set();",
      "  addEventListener('keydown',e=>{",
      "    keys.add(e.code);",
      "    if(e.code==='KeyP')paused=!paused;",
      "    if(e.code==='KeyR')hardReset();",
      "    if(e.code==='KeyF'){document.documentElement.requestFullscreen&&document.documentElement.requestFullscreen();}",
      "    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code))e.preventDefault();",
      "  });",
      "  addEventListener('keyup',e=>keys.delete(e.code));",
      "  let mouse={x:W/2,y:H/2,down:false};",
      "  addEventListener('mousemove',e=>{const r=c.getBoundingClientRect();mouse.x=(e.clientX-r.left);mouse.y=(e.clientY-r.top);},{passive:true});",
      "  addEventListener('mousedown',()=>mouse.down=true);",
      "  addEventListener('mouseup',()=>mouse.down=false);",
      "  const toast=document.getElementById('toast');",
      "  function toastMsg(s,ms){toast.textContent=s;setTimeout(()=>{if(toast.textContent===s)toast.textContent='';},ms||900)}",
      "  // -------- Audio (tiny) --------",
      "  let AC=null;",
      "  function blip(type,gain,freq,dur){",
      "    try{",
      "      AC=AC||new (window.AudioContext||window.webkitAudioContext)();",
      "      const t0=AC.currentTime;",
      "      const o=AC.createOscillator();",
      "      const g=AC.createGain();",
      "      o.type=type||'square';",
      "      o.frequency.setValueAtTime(freq||440,t0);",
      "      g.gain.setValueAtTime(0,t0);",
      "      g.gain.linearRampToValueAtTime(gain||0.05,t0+0.01);",
      "      g.gain.exponentialRampToValueAtTime(0.0001,t0+(dur||0.08));",
      "      o.connect(g).connect(AC.destination);",
      "      o.start(t0);",
      "      o.stop(t0+(dur||0.08)+0.02);",
      "    }catch(_){ }",
      "  }",
      "  // -------- Game constants --------",
      "  const TILE=16; // world tile size (logical)",
      "  const MAP_W=140;",
      "  const MAP_H=92;",
      "  const WORLD_W=MAP_W*TILE;",
      "  const WORLD_H=MAP_H*TILE;",
      "  const COLORS={",
      "    bg:'#070716',",
      "    neon1:'#50f1ff',",
      "    neon2:'#ff5be5',",
      "    acid:'#9cff57',",
      "    amber:'#ffd479',",
      "    text:'#dfe8ff',",
      "    wall:'#14132a',",
      "    floor:'#0b0b19',",
      "    floor2:'#0d1022',",
      "    grid:'#0a0a16'",
      "  };",
      "  // -------- State --------",
      "  let paused=false;",
      "  let seed=hashSeed(String(Date.now()));",
      "  let rng=mulberry32(seed);",
      "  let floorN=1;",
      "  let difficulty=1;",
      "  let tPrev=now();",
      "  // entities",
      "  const bullets=[];",
      "  const enemies=[];",
      "  const parts=[];",
      "  const drops=[];",
      "  const beams=[]; // rail traces",
      "  const doors=[];",
      "  const terminals=[];",
      "  // tilemap: 0 wall, 1 floor",
      "  let map=new Uint8Array(MAP_W*MAP_H);",
      "  // explored / fog",
      "  let seen=new Uint8Array(MAP_W*MAP_H);",
      "  // -------- Player / weapons --------",
      "  const WEAP={",
      "    pistol:{name:'Pistol',rate:180,spd:12,spread:0.03,dmg:10,heat:6,burst:1,ammoInf:true,shot:'tri',tone:620},",
      "    smg:{name:'SMG',rate:80,spd:12.5,spread:0.10,dmg:6,heat:4,burst:1,ammoInf:true,shot:'saw',tone:560},",
      "    shotgun:{name:'Shotgun',rate:420,spd:11.2,spread:0.45,dmg:5,heat:10,burst:7,ammoInf:true,shot:'square',tone:420},",
      "    rail:{name:'Rail',rate:520,spd:0,spread:0,dmg:40,heat:22,burst:1,ammoInf:true,shot:'sine',tone:980,rail:true},",
      "    nade:{name:'Grenade',rate:560,spd:8.5,spread:0.10,dmg:22,heat:16,burst:1,ammoInf:true,shot:'triangle',tone:280,arc:true}",
      "  };",
      "  const MODS=[",
      "    {k:'dmg',n:'Overclock',d:'Damage +15%',apply:p=>p.modDmg*=1.15},",
      "    {k:'rate',n:'Trigger Hack',d:'Fire rate +12%',apply:p=>p.modRate*=0.88},",
      "    {k:'heat',n:'Coolant Loop',d:'Heat -18%',apply:p=>p.modHeat*=0.82},",
      "    {k:'dash',n:'Kinetic Lattice',d:'Dash recharge +18%',apply:p=>p.modDash*=0.82},",
      "    {k:'hp',n:'Dermal Plating',d:'Max HP +20',apply:p=>{p.hpMax+=20;p.hp+=20;}}",
      "  ];",
      "  function mkPlayer(id){",
      "    const p={",
      "      id:id,",
      "      x:WORLD_W*(id===1?0.30:0.70),",
      "      y:WORLD_H*0.50,",
      "      vx:0,vy:0,",
      "      r:10,",
      "      hpMax:100,hp:100,",
      "      shieldMax:50,shield:20,",
      "      heat:0,heatMax:100,",
      "      dashCd:0,",
      "      hackCd:0,",
      "      alive:true,",
      "      score:0,credits:0,",
      "      weapon:'pistol',",
      "      wepCd:0,",
      "      // modifiers (stacking upgrades)",
      "      modDmg:1,modRate:1,modHeat:1,modDash:1",
      "    };",
      "    return p;",
      "  }",
      "  let P1=mkPlayer(1),P2=mkPlayer(2);",
      "  // -------- Leaderboard --------",
      "  const LB_KEY='neonrift_cyberpunk_lb_v1';",
      "  function loadLB(){try{return JSON.parse(localStorage.getItem(LB_KEY)||'[]')||[]}catch(_){return[]}}",
      "  function saveLB(rows){try{localStorage.setItem(LB_KEY,JSON.stringify(rows.slice(0,10)))}catch(_){}}",
      "  function addScore(points){",
      "    const rows=loadLB();",
      "    rows.push({t:Date.now(),s:points,f:floorN});",
      "    rows.sort((a,b)=>b.s-a.s);",
      "    saveLB(rows);",
      "  }",
      "  // -------- Level gen (rooms + corridors) --------",
      "  function idx(tx,ty){return tx+ty*MAP_W}",
      "  function inb(tx,ty){return tx>=0&&ty>=0&&tx<MAP_W&&ty<MAP_H}",
      "  function getT(tx,ty){return map[idx(tx,ty)]}",
      "  function setT(tx,ty,v){map[idx(tx,ty)]=v}",
      "  function carveRect(x0,y0,w,h){",
      "    for(let y=y0;y<y0+h;y++)for(let x=x0;x<x0+w;x++){",
      "      if(inb(x,y))setT(x,y,1);",
      "    }",
      "  }",
      "  function carveCorridor(x1,y1,x2,y2){",
      "    let x=x1,y=y1;",
      "    while(x!==x2){setT(x,y,1);x+=x<x2?1:-1}",
      "    while(y!==y2){setT(x,y,1);y+=y<y2?1:-1}",
      "  }",
      "  function floodFrom(sx,sy,mark){",
      "    const q=[sx,sy];",
      "    let n=0;",
      "    while(q.length){",
      "      const y=q.pop(),x=q.pop();",
      "      if(!inb(x,y))continue;",
      "      const ii=idx(x,y);",
      "      if(map[ii]!==1||mark[ii])continue;",
      "      mark[ii]=1;n++;",
      "      q.push(x+1,y,x-1,y,x,y+1,x,y-1);",
      "    }",
      "    return n;",
      "  }",
      "  function generateLevel(){",
      "    // reset",
      "    map=new Uint8Array(MAP_W*MAP_H);",
      "    seen=new Uint8Array(MAP_W*MAP_H);",
      "    enemies.length=0;bullets.length=0;parts.length=0;drops.length=0;beams.length=0;doors.length=0;terminals.length=0;",
      "    // new seed per floor for deterministic-ish feel",
      "    rng=mulberry32((seed + floorN*1337)>>>0);",
      "    const rooms=[];",
      "    const roomCount=12 + (floorN*1.2)|0;",
      "    const tries=roomCount*6;",
      "    for(let i=0;i<tries && rooms.length<roomCount;i++){",
      "      const w=6+(rng()*14)|0;",
      "      const h=6+(rng()*12)|0;",
      "      const x0=2+(rng()*(MAP_W-w-4))|0;",
      "      const y0=2+(rng()*(MAP_H-h-4))|0;",
      "      // overlap check w/ margin",
      "      let ok=true;",
      "      for(let r=0;r<rooms.length;r++){",
      "        const R=rooms[r];",
      "        if(x0+w+2<R.x || x0>R.x+R.w+2 || y0+h+2<R.y || y0>R.y+R.h+2){} else {ok=false;break}",
      "      }",
      "      reminder:;",
      "      if(!ok)continue;",
      "      rooms.push({x:x0,y:y0,w:w,h:h,cx:(x0+(w/2))|0,cy:(y0+(h/2))|0});",
      "      carveRect(x0,y0,w,h);",
      "    }",
      "    // Connect rooms via MST-ish (simple nearest chaining)",
      "    rooms.sort((a,b)=>a.cx-b.cx);",
      "    for(let i=1;i<rooms.length;i++){",
      "      const A=rooms[i-1],B=rooms[i];",
      "      carveCorridor(A.cx,A.cy,B.cx,B.cy);",
      "    }",
      "    // Clean: ensure single connected component (carve extra links if needed)",
      "    const mark=new Uint8Array(MAP_W*MAP_H);",
      "    if(rooms.length){floodFrom(rooms[0].cx,rooms[0].cy,mark);",
      "      for(let i=1;i<rooms.length;i++){",
      "        const R=rooms[i];",
      "        if(!mark[idx(R.cx,R.cy)]){",
      "          // connect to a previous room",
      "          const T=rooms[(rng()*i)|0];",
      "          carveCorridor(R.cx,R.cy,T.cx,T.cy);",
      "          floodFrom(R.cx,R.cy,mark);",
      "        }",
      "      }",
      "    }",
      "    // Place doors and terminals",
      "    function isWall(tx,ty){return inb(tx,ty)&&getT(tx,ty)===0}",
      "    function isFloor(tx,ty){return inb(tx,ty)&&getT(tx,ty)===1}",
      "    // Doors in some corridor chokepoints",
      "    for(let i=0;i<220;i++){",
      "      const tx=3+(rng()*(MAP_W-6))|0;",
      "      const ty=3+(rng()*(MAP_H-6))|0;",
      "      if(!isFloor(tx,ty))continue;",
      "      const n=isFloor(tx,ty-1),s=isFloor(tx,ty+1),w=isFloor(tx-1,ty),e=isFloor(tx+1,ty);",
      "      // corridor: NS open but EW walls OR vice versa",
      "      if((n&&s&&!w&&!e)||(w&&e&&!n&&!s)){",
      "        if(rng()<0.12){doors.push({tx:tx,ty:ty,open:false,lock:(rng()<0.55),hp:40});}",
      "      }",
      "    }",
      "    // Terminals in rooms",
      "    for(let i=0;i<rooms.length;i++){",
      "      if(rng()<0.35){",
      "        const R=rooms[i];",
      "        const tx=(R.x+2+(rng()*(R.w-4))|0),ty=(R.y+2+(rng()*(R.h-4))|0);",
      "        terminals.push({tx:tx,ty:ty,used:false,kind:(rng()<0.6?'door':'mod')});",
      "      }",
      "    }",
      "    // Spawn players near first room",
      "    if(rooms.length){",
      "      const S=rooms[0];",
      "      P1.x=(S.cx*TILE)+8;P1.y=(S.cy*TILE)+8;",
      "      P2.x=(S.cx*TILE)+32;P2.y=(S.cy*TILE)+8;",
      "    }",
      "    // Spawn enemies across rooms",
      "    const baseE=10 + (floorN*3)|0;",
      "    for(let i=0;i<baseE;i++){",
      "      const R=rooms[(1+(rng()*(rooms.length-1)))|0]||rooms[0];",
      "      const ex=(R.cx*TILE)+(rng()*R.w*TILE*0.6 - R.w*TILE*0.3);",
      "      const ey=(R.cy*TILE)+(rng()*R.h*TILE*0.6 - R.h*TILE*0.3);",
      "      spawnEnemy(ex,ey);",
      "    }",
      "    // Drop some pickups",
      "    for(let i=0;i<6 + (floorN*0.4)|0;i++){",
      "      const tx=(3+(rng()*(MAP_W-6))|0),ty=(3+(rng()*(MAP_H-6))|0);",
      "      if(getT(tx,ty)!==1)continue;",
      "      const kind=rng()<0.45?'heal':(rng()<0.75?'cred':'mod');",
      "      drops.push({x:tx*TILE+8,y:ty*TILE+8,kind:kind,v:0,ttl:1e9});",
      "    }",
      "  }",
      "  // -------- Collisions --------",
      "  function tileAtWorld(wx,wy){",
      "    const tx=(wx/TILE)|0,ty=(wy/TILE)|0;",
      "    if(!inb(tx,ty))return 0;",
      "    return getT(tx,ty);",
      "  }",
      "  function solidAtWorld(wx,wy){",
      "    const tx=(wx/TILE)|0,ty=(wy/TILE)|0;",
      "    if(!inb(tx,ty))return true;",
      "    // door closed counts solid",
      "    if(getT(tx,ty)===0)return true;",
      "    for(let i=0;i<doors.length;i++){",
      "      const d=doors[i];",
      "      if(d.tx===tx&&d.ty===ty && !d.open) return true;",
      "    }",
      "    return false;",
      "  }",
      "  function moveWithColl(p,dt){",
      "    // simple circle collide vs solid tiles",
      "    const r=p.r;",
      "    let nx=p.x+p.vx, ny=p.y+p.vy;",
      "    // X axis",
      "    if(!solidAtWorld(nx+r, p.y) && !solidAtWorld(nx-r, p.y) && !solidAtWorld(nx, p.y+r) && !solidAtWorld(nx, p.y-r)){",
      "      p.x=nx;",
      "    } else {",
      "      p.vx*= -0.25;",
      "    }",
      "    // Y axis",
      "    if(!solidAtWorld(p.x+r, ny) && !solidAtWorld(p.x-r, ny) && !solidAtWorld(p.x, ny+r) && !solidAtWorld(p.x, ny-r)){",
      "      p.y=ny;",
      "    } else {",
      "      p.vy*= -0.25;",
      "    }",
      "    p.x=clamp(p.x,16,WORLD_W-16);p.y=clamp(p.y,16,WORLD_H-16);",
      "  }",
      "  // -------- Particles / FX --------",
      "  function puff(x0,y0,col,n,sp,life){",
      "    for(let i=0;i<n;i++){",
      "      const a=rng()*TAU;const s=(rng()*(sp||3))+0.2;",
      "      parts.push({x:x0,y:y0,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:1+(rng()*3),a:0,life:life||520,col:col});",
      "    }",
      "  }",
      "  function sparkle(x0,y0,col){puff(x0,y0,col,12,3.5,420)}",
      "  // -------- Enemies --------",
      "  function spawnEnemy(x0,y0){",
      "    const t=(rng()<0.55)?'drone':(rng()<0.85?'slicer':'brute');",
      "    let hp=24,spd=1.6,r=9,shot=0,range=120,val=40,col='#79ffdf';",
      "    if(t==='slicer'){hp=18;spd=2.35;r=8;range=90;val=45;col='#9ab0ff'}",
      "    if(t==='brute'){hp=70;spd=1.05;r=12;range=170;val=95;col='#ffcf7d'}",
      "    // scale by difficulty",
      "    hp=(hp*(1+0.08*(floorN-1)))|0;",
      "    enemies.push({t:t,x:x0,y:y0,vx:0,vy:0,r:r,hp:hp,hpMax:hp,spd:spd,cd:0,shot:shot,range:range,val:val,col:col,alive:true,stun:0});",
      "  }",
      "  function pickTarget(e){",
      "    const a=P1.alive?P1:null;const b=P2.alive?P2:null;",
      "    if(!a) return b;",
      "    if(!b) return a;",
      "    const da=(a.x-e.x)*(a.x-e.x)+(a.y-e.y)*(a.y-e.y);",
      "    const db=(b.x-e.x)*(b.x-e.x)+(b.y-e.y)*(b.y-e.y);",
      "    return da<db?a:b;",
      "  }",
      "  function damagePlayer(p,amt){",
      "    if(!p.alive) return;",
      "    // shield first",
      "    let s=Math.min(p.shield,amt);",
      "    p.shield-=s;amt-=s;",
      "    if(amt>0)p.hp-=amt;",
      "    puff(p.x,p.y,(p.id===1?COLORS.neon1:COLORS.neon2),18,3.4,520);",
      "    blip('triangle',0.03,220,0.06);",
      "    if(p.hp<=0){p.alive=false;toastMsg('AGENT DOWN',700);} ",
      "  }",
      "  function damageEnemy(src,e,amt){",
      "    if(!e.alive) return;",
      "    e.hp-=amt;",
      "    src.score+=amt|0;",
      "    sparkle(e.x,e.y,e.col);",
      "    if(e.hp<=0){",
      "      e.alive=false;",
      "      src.score+=e.val;src.credits+=(e.val/5)|0;",
      "      puff(e.x,e.y,e.col,32,4.4,820);",
      "      // chance drop",
      "      if(rng()<0.18){drops.push({x:e.x,y:e.y,kind:(rng()<0.55?'cred':(rng()<0.75?'heal':'mod')),v:0,ttl:1e9});}",
      "      blip('sawtooth',0.04,140,0.10);",
      "    }",
      "  }",
      "  // -------- Bullets / weapons --------",
      "  function fireBullet(owner,x0,y0,dx,dy,spd,dmg,life,kind){",
      "    const m=hypot(dx,dy)||1;",
      "    bullets.push({o:owner,x:x0,y:y0,vx:dx/m*spd,vy:dy/m*spd,r:3,d:dmg,life:life||900,a:0,k:kind||'b'});",
      "  }",
      "  function explode(x0,y0,rad,dmg,owner){",
      "    puff(x0,y0,COLORS.amber,42,5.2,900);",
      "    // enemies",
      "    for(let i=0;i<enemies.length;i++){",
      "      const e=enemies[i];if(!e.alive)continue;",
      "      const dx=e.x-x0,dy=e.y-y0;const dd=dx*dx+dy*dy;",
      "      if(dd<rad*rad){damageEnemy(owner,e,((dmg*(1-(Math.sqrt(dd)/rad)))|0)+4);} ",
      "    }",
      "    // players friendly fire small",
      "    for(const p of [P1,P2]){",
      "      if(!p.alive)continue;",
      "      const dx=p.x-x0,dy=p.y-y0;const dd=dx*dx+dy*dy;",
      "      if(dd<rad*rad){damagePlayer(p, ((dmg*0.35*(1-(Math.sqrt(dd)/rad)))|0)+1);} ",
      "    }",
      "    blip('square',0.06,120,0.12);",
      "  }",
      "  function shoot(p,aimX,aimY,dt){",
      "    if(!p.alive) return;",
      "    const Wp=WEAP[p.weapon];",
      "    const rate=Wp.rate*p.modRate;",
      "    if(p.wepCd>0) return;",
      "    // overheat check",
      "    if(p.heat>=p.heatMax){",
      "      // clicking into overheat does nothing",
      "      return;",
      "    }",
      "    p.wepCd=rate;",
      "    const dx=aimX-p.x,dy=aimY-p.y;const ang=Math.atan2(dy,dx);",
      "    const burst=Wp.burst|0;",
      "    const baseDmg=(Wp.dmg*p.modDmg)|0;",
      "    const heatAdd=Wp.heat*p.modHeat;",
      "    p.heat=Math.min(p.heatMax,p.heat+heatAdd);",
      "    // muzzle fx",
      "    puff(p.x+Math.cos(ang)*10,p.y+Math.sin(ang)*10,(p.id===1?COLORS.neon1:COLORS.neon2),8,2.8,240);",
      "    // rail special",
      "    if(Wp.rail){",
      "      // raycast until wall or max",
      "      const maxLen=680;",
      "      let sx=p.x,sy=p.y;",
      "      let ex=sx+Math.cos(ang)*maxLen,ey=sy+Math.sin(ang)*maxLen;",
      "      // step forward in small increments to stop at wall",
      "      let t=0;let hitX=ex,hitY=ey;",
      "      for(let i=0;i<maxLen;i+=8){",
      "        const xx=sx+Math.cos(ang)*i, yy=sy+Math.sin(ang)*i;",
      "        if(solidAtWorld(xx,yy)){hitX=xx;hitY=yy;break;}",
      "        // hit first enemy along line (thin)",
      "        for(let j=0;j<enemies.length;j++){",
      "          const e=enemies[j];if(!e.alive)continue;",
      "          const dd=(e.x-xx)*(e.x-xx)+(e.y-yy)*(e.y-yy);",
      "          if(dd<(e.r+4)*(e.r+4)){damageEnemy(p,e,baseDmg);}",
      "        }",
      "      }",
      "      beams.push({x1:sx,y1:sy,x2:hitX,y2:hitY,t:0,life:120,col:(p.id===1?COLORS.neon1:COLORS.neon2)});",
      "      blip(Wp.shot,0.04,Wp.tone,0.05);",
      "      return;",
      "    }",
      "    // grenades",
      "    if(Wp.arc){",
      "      // slow projectile that explodes",
      "      fireBullet(p,p.x,p.y,dx,dy,Wp.spd*1.0,baseDmg,1300,'g');",
      "      blip(Wp.shot,0.04,Wp.tone,0.06);",
      "      return;",
      "    }",
      "    for(let i=0;i<burst;i++){",
      "      const s=(rng()-0.5)*Wp.spread;",
      "      const a=ang+s;",
      "      fireBullet(p,p.x,p.y,Math.cos(a),Math.sin(a),Wp.spd,baseDmg,900,'b');",
      "    }",
      "    blip(Wp.shot,0.035,Wp.tone,0.04);",
      "  }",
      "  // -------- Interactions (doors/terminals/hack) --------",
      "  function nearTile(p,tx,ty,dist){",
      "    const cx=tx*TILE+8,cy=ty*TILE+8;",
      "    const dx=p.x-cx,dy=p.y-cy;return (dx*dx+dy*dy)<(dist*dist);",
      "  }",
      "  function hackPulse(p){",
      "    if(!p.alive) return;",
      "    if(p.hackCd>0) return;",
      "    if(p.heat>85) return;",
      "    p.hackCd=900; p.heat=Math.min(p.heatMax,p.heat+18);",
      "    // reveal map nearby and stun enemies",
      "    const R=220;",
      "    puff(p.x,p.y,COLORS.acid,60,5.2,820);",
      "    for(let i=0;i<enemies.length;i++){",
      "      const e=enemies[i];if(!e.alive)continue;",
      "      const dx=e.x-p.x,dy=e.y-p.y;const dd=dx*dx+dy*dy;",
      "      if(dd<R*R){e.stun=520;}",
      "    }",
      "    // open unlocked doors in radius",
      "    for(let i=0;i<doors.length;i++){",
      "      const d=doors[i];",
      "      const cx=d.tx*TILE+8,cy=d.ty*TILE+8;",
      "      const dx=cx-p.x,dy=cy-p.y;const dd=dx*dx+dy*dy;",
      "      if(dd<R*R && !d.lock){d.open=true;}",
      "    }",
      "    blip('sine',0.05,180,0.10);",
      "    toastMsg('HACK PULSE',650);",
      "  }",
      "  function useTerminal(p){",
      "    for(let i=0;i<terminals.length;i++){",
      "      const t=terminals[i];if(t.used)continue;",
      "      if(nearTile(p,t.tx,t.ty,26)){",
      "        t.used=true;",
      "        puff(t.tx*TILE+8,t.ty*TILE+8,COLORS.acid,28,4.2,780);",
      "        blip('triangle',0.04,520,0.08);",
      "        if(t.kind==='door'){",
      "          // unlock and open a few doors",
      "          let opened=0;",
      "          for(let j=0;j<doors.length;j++){",
      "            const d=doors[j];",
      "            if(d.lock && rng()<0.55){d.lock=false;d.open=true;opened++;}",
      "          }",
      "          toastMsg('Terminal: Doors unlocked ('+opened+')',900);",
      "        }else{",
      "          // grant mod",
      "          const m=pick(MODS);",
      "          m.apply(p);",
      "          toastMsg('Mod installed: '+m.n,1000);",
      "        }",
      "        return;",
      "      }",
      "    }",
      "  }",
      "  // -------- Pickups --------",
      "  function pickup(p){",
      "    for(let i=drops.length;i--;){",
      "      const d=drops[i];",
      "      const dx=p.x-d.x,dy=p.y-d.y;",
      "      if(dx*dx+dy*dy<18*18){",
      "        if(d.kind==='heal'){p.hp=Math.min(p.hpMax,p.hp+28);p.shield=Math.min(p.shieldMax,p.shield+10);toastMsg('Patch kit +HP',600);blip('sine',0.03,660,0.06);}",
      "        else if(d.kind==='cred'){p.credits+=25+(rng()*35)|0;toastMsg('Credits +',500);blip('square',0.03,760,0.05);} ",
      "        else if(d.kind==='mod'){",
      "          const m=pick(MODS);m.apply(p);toastMsg('Loot mod: '+m.n,900);blip('triangle',0.03,920,0.06);",
      "        }",
      "        drops.splice(i,1);",
      "      }",
      "    }",
      "  }",
      "  // -------- Cameras / Viewports --------",
      "  function makeView(top,h,p){return{top:top,h:h,w:pc.width,ph:pc.height,camX:0,camY:0,p:p};}",
      "  function updView(v){",
      "    // camera in world pixels; view size in world pixels derived from pixel buffer / scale",
      "    const viewW=(pc.width*PIX_SCALE);",
      "    const viewH=(v.h*PIX_SCALE);",
      "    v.camX=clamp(v.p.x-viewW/2,0,WORLD_W-viewW);",
      "    v.camY=clamp(v.p.y-viewH/2,0,WORLD_H-viewH);",
      "    v.viewW=viewW;v.viewH=viewH;",
      "  }",
      "  // -------- Fog of war --------",
      "  function reveal(p){",
      "    const tx=(p.x/TILE)|0,ty=(p.y/TILE)|0;",
      "    for(let yy=-6;yy<=6;yy++)for(let xx=-8;xx<=8;xx++){",
      "      const x0=tx+xx,y0=ty+yy;",
      "      if(inb(x0,y0))seen[idx(x0,y0)]=1;",
      "    }",
      "  }",
      "  // -------- Update loops --------",
      "  function updatePlayer(p,dt,v){",
      "    if(!p.alive) return;",
      "    reveal(p);",
      "    // cooldowns",
      "    p.wepCd=Math.max(0,p.wepCd-dt);",
      "    p.dashCd=Math.max(0,p.dashCd-dt);",
      "    p.hackCd=Math.max(0,p.hackCd-dt);",
      "    // cool heat",
      "    p.heat=Math.max(0,p.heat-dt*0.035*(p.modHeat<1?1.2:1));",
      "    // shield regen",
      "    if(p.shield<p.shieldMax) p.shield=Math.min(p.shieldMax,p.shield+dt*0.010);",
      "    // movement input",
      "    let ax=0,ay=0;",
      "    if(p.id===1){",
      "      if(keys.has('KeyW'))ay-=1;if(keys.has('KeyS'))ay+=1;if(keys.has('KeyA'))ax-=1;if(keys.has('KeyD'))ax+=1;",
      "    }else{",
      "      if(keys.has('ArrowUp'))ay-=1;if(keys.has('ArrowDown'))ay+=1;if(keys.has('ArrowLeft'))ax-=1;if(keys.has('ArrowRight'))ax+=1;",
      "    }",
      "    const m=hypot(ax,ay)||1;ax/=m;ay/=m;",
      "    const accel=0.020*(PIX_SCALE);",
      "    p.vx=lerp(p.vx,p.vx+ax*accel*dt,0.20);",
      "    p.vy=lerp(p.vy,p.vy+ay*accel*dt,0.20);",
      "    p.vx*=Math.pow(0.994,dt);p.vy*=Math.pow(0.994,dt);",
      "    // dash",
      "    const dashKey=(p.id===1?keys.has('ShiftLeft'):keys.has('ShiftRight'));",
      "    if(dashKey && p.dashCd<=0){",
      "      const dashMult=p.modDash;",
      "      p.dashCd=560*dashMult;",
      "      p.vx+=ax*7.5; p.vy+=ay*7.5;",
      "      puff(p.x,p.y,(p.id===1?COLORS.neon1:COLORS.neon2),24,4.2,520);",
      "      blip('triangle',0.03,520,0.06);",
      "    }",
      "    moveWithColl(p,dt);",
      "    // interactions",
      "    useTerminal(p);",
      "    pickup(p);",
      "    // aiming / shooting",
      "    let aimX=0,aimY=0,shooting=false,hacking=false;",
      "    if(p.id===1){",
      "      aimX=v.camX + (mouse.x*DPR)/1; // mouse is in CSS px; DPR cancels in pixel-buffer render; good enough",
      "      aimY=v.camY + (mouse.y*DPR - v.top*(PIX_SCALE))/1;",
      "      shooting=mouse.down;",
      "      hacking=keys.has('KeyQ');",
      "    }else{",
      "      // auto aim to nearest visible enemy",
      "      let best=null,bd=1e18;",
      "      for(let i=0;i<enemies.length;i++){",
      "        const e=enemies[i];if(!e.alive)continue;",
      "        const dx=e.x-p.x,dy=e.y-p.y;const dd=dx*dx+dy*dy;",
      "        if(dd<bd){bd=dd;best=e}",
      "      }",
      "      aimX=best?best.x:(p.x+32);aimY=best?best.y:p.y;",
      "      shooting=keys.has('Enter');",
      "      hacking=keys.has('Slash');",
      "    }",
      "    if(hacking) hackPulse(p);",
      "    if(shooting) shoot(p,aimX,aimY,dt);",
      "    // weapon swap via heat thresholds (simple progression) or credits",
      "    // (keep accessible without extra UI): rail unlock later",
      "    if(floorN>=2 && p.weapon==='pistol' && p.credits>80) p.weapon='smg';",
      "    if(floorN>=3 && p.weapon==='smg' && p.credits>160) p.weapon='shotgun';",
      "    if(floorN>=5 && (p.weapon==='shotgun'||p.weapon==='smg') && p.credits>260) p.weapon='rail';",
      "    if(floorN>=4 && p.credits>210 && p.weapon!=='nade' && rng()<0.01) p.weapon='nade';",
      "  }",
      "  function updateEnemies(dt){",
      "    for(let i=0;i<enemies.length;i++){",
      "      const e=enemies[i]; if(!e.alive) continue;",
      "      if(e.stun>0){e.stun-=dt; e.vx*=0.90; e.vy*=0.90; e.x+=e.vx; e.y+=e.vy; continue;}",
      "      e.cd=Math.max(0,e.cd-dt);",
      "      const t=pickTarget(e); if(!t) continue;",
      "      const dx=t.x-e.x,dy=t.y-e.y; const d=hypot(dx,dy)||1;",
      "      const ux=dx/d,uy=dy/d;",
      "      // behavior by type",
      "      if(e.t==='drone'){",
      "        // hover and shoot from mid range",
      "        const desired=e.range;",
      "        const pull=(d>desired?1:-1);",
      "        e.vx=lerp(e.vx,ux*e.spd*pull*0.8,0.020*dt);",
      "        e.vy=lerp(e.vy,uy*e.spd*pull*0.8,0.020*dt);",
      "        if(d<desired*1.25 && e.cd<=0 && rng()<0.65){",
      "          e.cd=520-(floorN*12);",
      "          fireBullet(e,e.x,e.y,dx,dy,9.5,6+(difficulty|0),900,'eb');",
      "          blip('square',0.02,420,0.04);",
      "        }",
      "      }else if(e.t==='slicer'){",
      "        // rush and melee",
      "        e.vx=lerp(e.vx,ux*e.spd*1.35,0.028*dt);",
      "        e.vy=lerp(e.vy,uy*e.spd*1.35,0.028*dt);",
      "      }else{",
      "        // brute: slow, burst shots",
      "        e.vx=lerp(e.vx,ux*e.spd*0.95,0.018*dt);",
      "        e.vy=lerp(e.vy,uy*e.spd*0.95,0.018*dt);",
      "        if(d<e.range*1.4 && e.cd<=0){",
      "          e.cd=820-(floorN*14);",
      "          // 3 shot spread",
      "          const a=Math.atan2(dy,dx);",
      "          for(let s=-1;s<=1;s++){",
      "            const aa=a+s*0.14;",
      "            fireBullet(e,e.x,e.y,Math.cos(aa),Math.sin(aa),8.8,8+(difficulty|0),950,'eb');",
      "          }",
      "          blip('sawtooth',0.03,280,0.06);",
      "        }",
      "      }",
      "      // collision with world",
      "      const ex=e.x+e.vx,ey=e.y+e.vy;",
      "      if(!solidAtWorld(ex, e.y)) e.x=ex; else e.vx*=-0.30;",
      "      if(!solidAtWorld(e.x, ey)) e.y=ey; else e.vy*=-0.30;",
      "      // bump players",
      "      for(const p of [P1,P2]){",
      "        if(!p.alive) continue;",
      "        const rr=(e.r+p.r+2);",
      "        const dd=(e.x-p.x)*(e.x-p.x)+(e.y-p.y)*(e.y-p.y);",
      "        if(dd<rr*rr){",
      "          if(e.t==='slicer'){damagePlayer(p,13+(difficulty|0));}",
      "          else damagePlayer(p,8+(difficulty|0));",
      "          // knockback",
      "          p.vx+=(p.x-e.x)*0.015; p.vy+=(p.y-e.y)*0.015;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  function updateBullets(dt){",
      "    for(let i=bullets.length;i--;){",
      "      const b=bullets[i];",
      "      b.a+=dt;",
      "      // grenade arcs: slow down a bit",
      "      if(b.k==='g'){b.vx*=0.995;b.vy*=0.995;}",
      "      b.x+=b.vx;b.y+=b.vy;",
      "      if(b.a>b.life){",
      "        if(b.k==='g'){explode(b.x,b.y,90,26,b.o);} ",
      "        bullets.splice(i,1);continue;",
      "      }",
      "      // wall collision",
      "      if(solidAtWorld(b.x,b.y)){",
      "        if(b.k==='g'){explode(b.x,b.y,90,26,b.o);} ",
      "        bullets.splice(i,1);continue;",
      "      }",
      "      if(b.o===P1 || b.o===P2){",
      "        // hit enemies",
      "        for(let j=0;j<enemies.length;j++){",
      "          const e=enemies[j];if(!e.alive)continue;",
      "          const rr=e.r+b.r+2;",
      "          const dd=(b.x-e.x)*(b.x-e.x)+(b.y-e.y)*(b.y-e.y);",
      "          if(dd<rr*rr){",
      "            damageEnemy(b.o,e,b.d);",
      "            if(b.k==='g'){explode(b.x,b.y,90,26,b.o);} ",
      "            bullets.splice(i,1);break;",
      "          }",
      "        }",
      "      }else{",
      "        // enemy bullet hits players",
      "        for(const p of [P1,P2]){",
      "          if(!p.alive)continue;",
      "          const rr=p.r+b.r+2;",
      "          const dd=(b.x-p.x)*(b.x-p.x)+(b.y-p.y)*(b.y-p.y);",
      "          if(dd<rr*rr){damagePlayer(p,b.d);bullets.splice(i,1);break;}",
      "        }",
      "      }",
      "    }",
      "  }",
      "  function updateParts(dt){",
      "    for(let i=parts.length;i--;){",
      "      const p=parts[i];",
      "      p.a+=dt;",
      "      if(p.a>p.life){parts.splice(i,1);continue;}",
      "      p.x+=p.vx;p.y+=p.vy;",
      "      p.vx*=0.985;p.vy*=0.985;",
      "      p.r*=0.992;",
      "    }",
      "    for(let i=beams.length;i--;){",
      "      const b=beams[i];b.t+=dt;if(b.t>b.life){beams.splice(i,1);} ",
      "    }",
      "  }",
      "  function updateDoors(){",
      "    // auto open when near if unlocked",
      "    for(let i=0;i<doors.length;i++){",
      "      const d=doors[i];",
      "      if(d.open) continue;",
      "      const cx=d.tx*TILE+8,cy=d.ty*TILE+8;",
      "      const near=(p)=>p.alive && ((p.x-cx)*(p.x-cx)+(p.y-cy)*(p.y-cy)<22*22);",
      "      if(!d.lock && (near(P1)||near(P2))) d.open=true;",
      "    }",
      "  }",
      "  // -------- Progression / Floor exit --------",
      "  let exitPortal={x:0,y:0,active:false};",
      "  function spawnExit(){",
      "    // choose a floor tile far from players",
      "    for(let k=0;k<600;k++){",
      "      const tx=3+(rng()*(MAP_W-6))|0,ty=3+(rng()*(MAP_H-6))|0;",
      "      if(getT(tx,ty)!==1) continue;",
      "      const x0=tx*TILE+8,y0=ty*TILE+8;",
      "      const d1=(x0-P1.x)*(x0-P1.x)+(y0-P1.y)*(y0-P1.y);",
      "      if(d1<420*420) continue;",
      "      exitPortal={x:x0,y:y0,active:true};",
      "      toastMsg('Exit portal online',900);",
      "      puff(x0,y0,COLORS.acid,60,5.0,900);",
      "      return;",
      "    }",
      "  }",
      "  function tryExit(p){",
      "    if(!exitPortal.active) return false;",
      "    const dx=p.x-exitPortal.x,dy=p.y-exitPortal.y;",
      "    if(dx*dx+dy*dy<26*26){",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "  // -------- Rendering (pixel art vibe) --------",
      "  function palNoise(tx,ty){",
      "    // deterministic-ish noise for tiles",
      "    const v=((tx*374761393 + ty*668265263 + (seed|0))>>>0);",
      "    return (v ^ (v>>>13)) & 255;",
      "  }",
      "  function drawTile(v,tx,ty,screenX,screenY){",
      "    // fog",
      "    const ii=idx(tx,ty);",
      "    const s=seen[ii];",
      "    if(!s) return;",
      "    const t=getT(tx,ty);",
      "    if(t===0){",
      "      // wall pixel block with neon edges",
      "      px.fillStyle=COLORS.wall;",
      "      px.fillRect(screenX,screenY,1,1);",
      "      // slight neon glint",
      "      const n=palNoise(tx,ty);",
      "      if((n&15)===0){px.fillStyle='#2a2a5a';px.fillRect(screenX,screenY,1,1);}",
      "    }else{",
      "      const n=palNoise(tx,ty);",
      "      px.fillStyle=(n&1)?COLORS.floor:COLORS.floor2;",
      "      px.fillRect(screenX,screenY,1,1);",
      "      // occasional accent pixel",
      "      if((n&31)===0){px.fillStyle='#111136';px.fillRect(screenX,screenY,1,1);}",
      "    }",
      "  }",
      "  function drawEntityDot(v,wx,wy,col){",
      "    const sx=((wx - v.camX)/PIX_SCALE)|0;",
      "    const sy=((wy - v.camY)/PIX_SCALE + (v.top/PIX_SCALE))|0;",
      "    if(sx<0||sy<0||sx>=pc.width||sy>=pc.height) return;",
      "    px.fillStyle=col;px.fillRect(sx,sy,1,1);",
      "  }",
      "  function drawView(v){",
      "    // Clear view region in pixel buffer",
      "    px.fillStyle=COLORS.bg;",
      "    px.fillRect(0,(v.top/PIX_SCALE)|0,pc.width,(v.h/PIX_SCALE)|0);",
      "    // Background grid faint",
      "    const topPix=(v.top/PIX_SCALE)|0;",
      "    const hPix=(v.h/PIX_SCALE)|0;",
      "    px.fillStyle=COLORS.grid;",
      "    for(let yy=topPix;yy<topPix+hPix;yy+=6){",
      "      px.fillRect(0,yy,pc.width,1);",
      "    }",
      "    // tiles: sample at 1 pixel per tile (~16 world px). We map tile coords to pixel coords.",
      "    const viewW=v.viewW, viewH=v.viewH;",
      "    const tx0=(v.camX/TILE)|0, ty0=(v.camY/TILE)|0;",
      "    const tx1=((v.camX+viewW)/TILE)|0, ty1=((v.camY+viewH)/TILE)|0;",
      "    for(let ty=ty0;ty<=ty1;ty++){",
      "      for(let tx=tx0;tx<=tx1;tx++){",
      "        if(!inb(tx,ty)) continue;",
      "        const wx=tx*TILE+8, wy=ty*TILE+8;",
      "        const sx=((wx - v.camX)/PIX_SCALE)|0;",
      "        const sy=((wy - v.camY)/PIX_SCALE + (v.top/PIX_SCALE))|0;",
      "        drawTile(v,tx,ty,sx,sy);",
      "      }",
      "    }",
      "    // doors & terminals",
      "    for(let i=0;i<doors.length;i++){",
      "      const d=doors[i];",
      "      const col=d.open?'#2a2a40':(d.lock?'#ff6a7a':'#7aa8ff');",
      "      drawEntityDot(v,d.tx*TILE+8,d.ty*TILE+8,col);",
      "    }",
      "    for(let i=0;i<terminals.length;i++){",
      "      const t=terminals[i];",
      "      drawEntityDot(v,t.tx*TILE+8,t.ty*TILE+8,(t.used?'#2a2a40':COLORS.acid));",
      "    }",
      "    // drops",
      "    for(let i=0;i<drops.length;i++){",
      "      const d=drops[i];",
      "      const col=(d.kind==='heal')?'#7cffc8':(d.kind==='cred')?'#ffd479':'#9cff57';",
      "      drawEntityDot(v,d.x,d.y,col);",
      "    }",
      "    // exit",
      "    if(exitPortal.active){drawEntityDot(v,exitPortal.x,exitPortal.y,COLORS.acid);}",
      "    // bullets",
      "    for(let i=0;i<bullets.length;i++){",
      "      const b=bullets[i];",
      "      drawEntityDot(v,b.x,b.y,(b.o===P1?COLORS.neon1:(b.o===P2?COLORS.neon2:'#ffcf7d')));",
      "    }",
      "    // enemies",
      "    for(let i=0;i<enemies.length;i++){",
      "      const e=enemies[i];if(!e.alive)continue;",
      "      drawEntityDot(v,e.x,e.y,e.col);",
      "      // hp tick",
      "      if(e.hp<e.hpMax){",
      "        drawEntityDot(v,e.x+6,e.y-6,'#111');",
      "      }",
      "    }",
      "    // players",
      "    if(v.p.alive) drawEntityDot(v,v.p.x,v.p.y,(v.p.id===1?COLORS.neon1:COLORS.neon2));",
      "    // beams",
      "    for(let i=0;i<beams.length;i++){",
      "      const b=beams[i];",
      "      // draw sparse dots along beam",
      "      const dx=b.x2-b.x1,dy=b.y2-b.y1;const L=hypot(dx,dy)||1;",
      "      const ux=dx/L,uy=dy/L;",
      "      const step=18;",
      "      for(let s=0;s<L;s+=step){",
      "        drawEntityDot(v,b.x1+ux*s,b.y1+uy*s,b.col);",
      "      }",
      "    }",
      "    // scanlines overlay in pixel buffer",
      "    px.fillStyle='rgba(0,0,0,0.10)';",
      "    for(let yy=topPix;yy<topPix+hPix;yy+=2){px.fillRect(0,yy,pc.width,1)}",
      "    // minimap (top-left of each view)",
      "    const mmW=52,mmH=34;",
      "    const baseX=2, baseY=topPix+2;",
      "    // frame",
      "    px.fillStyle='rgba(0,0,0,0.65)';px.fillRect(baseX,baseY,mmW,mmH);",
      "    // player dot on minimap",
      "    const mx=baseX+(((v.p.x/WORLD_W)*(mmW-4))|0)+2;",
      "    const my=baseY+(((v.p.y/WORLD_H)*(mmH-4))|0)+2;",
      "    px.fillStyle=(v.p.id===1?COLORS.neon1:COLORS.neon2);px.fillRect(mx,my,2,2);",
      "  }",
      "  function drawHUD(){",
      "    // scale pixel buffer to screen",
      "    x.imageSmoothingEnabled=false;",
      "    x.drawImage(pc,0,0,W,H);",
      "    // split line",
      "    x.fillStyle='rgba(255,255,255,0.08)';x.fillRect(0,(H/2)|0,W,2);",
      "    // text overlay (normal canvas, not pixel)",
      "    x.font=(12*DPR)+'px system-ui';",
      "    x.fillStyle='rgba(255,255,255,0.85)';",
      "    // scores",
      "    const s1='P1 '+(P1.score|0)+'  $'+(P1.credits|0)+'  '+WEAP[P1.weapon].name;",
      "    const s2='P2 '+(P2.score|0)+'  $'+(P2.credits|0)+'  '+WEAP[P2.weapon].name;",
      "    x.fillText(s1,12*DPR,18*DPR);",
      "    x.fillText(s2,12*DPR,(H/2)+18*DPR);",
      "    // bars",
      "    function bar(x0,y0,w,h,v,col){x.fillStyle='rgba(255,255,255,0.10)';x.fillRect(x0,y0,w,h);x.fillStyle=col;x.fillRect(x0,y0,w*clamp(v,0,1),h)}",
      "    bar(12*DPR,24*DPR,140*DPR,8*DPR,P1.hp/P1.hpMax,COLORS.neon1);",
      "    bar(12*DPR,34*DPR,140*DPR,6*DPR,P1.shield/P1.shieldMax,'#9ab0ff');",
      "    bar(12*DPR,44*DPR,140*DPR,6*DPR,(1-P1.heat/P1.heatMax),'#7cffc8');",
      "    bar(12*DPR,(H/2)+24*DPR,140*DPR,8*DPR,P2.hp/P2.hpMax,COLORS.neon2);",
      "    bar(12*DPR,(H/2)+34*DPR,140*DPR,6*DPR,P2.shield/P2.shieldMax,'#ff9adf');",
      "    bar(12*DPR,(H/2)+44*DPR,140*DPR,6*DPR,(1-P2.heat/P2.heatMax),'#7cffc8');",
      "    // watermark",
      "    x.fillStyle='rgba(255,255,255,0.22)';",
      "    x.fillText('freegameslist.blog',12*DPR,H-12*DPR);",
      "    // paused overlay",
      "    if(paused){",
      "      x.fillStyle='rgba(0,0,0,0.60)';x.fillRect(0,0,W,H);",
      "      x.fillStyle='rgba(255,255,255,0.92)';x.font=(36*DPR)+'px system-ui';",
      "      x.fillText('PAUSED',W/2-68*DPR,H/2);",
      "    }",
      "  }",
      "  // -------- Game over / restart --------",
      "  function allDead(){return !P1.alive && !P2.alive;}",
      "  function hardReset(){",
      "    floorN=1;difficulty=1;",
      "    P1=mkPlayer(1);P2=mkPlayer(2);",
      "    exitPortal={x:0,y:0,active:false};",
      "    generateLevel();",
      "    toastMsg('New run (Floor 1)',900);",
      "    paused=false;",
      "  }",
      "  // -------- Main loop --------",
      "  function step(){",
      "    const t=now();",
      "    const dt=Math.min(33,t-tPrev);",
      "    tPrev=t;",
      "    if(!paused){",
      "      // if portal not active and enemies mostly cleared, spawn it",
      "      let aliveE=0;for(let i=0;i<enemies.length;i++) if(enemies[i].alive) aliveE++;",
      "      if(!exitPortal.active && aliveE<=2){spawnExit();}",
      "      // views (split screen in pixel buffer)",
      "      const v1=makeView(0, (innerHeight/2)|0, P1);",
      "      const v2=makeView((innerHeight/2)|0, (innerHeight/2)|0, P2);",
      "      updView(v1);updView(v2);",
      "      updatePlayer(P1,dt,v1);",
      "      updatePlayer(P2,dt,v2);",
      "      updateDoors();",
      "      updateEnemies(dt);",
      "      updateBullets(dt);",
      "      updateParts(dt);",
      "      // exit check: require at least one alive player in portal",
      "      const ex=(P1.alive && tryExit(P1)) || (P2.alive && tryExit(P2));",
      "      if(ex){",
      "        floorN++;difficulty=1+(floorN*0.35);",
      "        exitPortal.active=false;",
      "        // reward floor clear",
      "        if(P1.alive){P1.credits+=60+(floorN*10)|0;P1.score+=120;}",
      "        if(P2.alive){P2.credits+=60+(floorN*10)|0;P2.score+=120;}",
      "        generateLevel();",
      "        toastMsg('Floor '+floorN,900);",
      "      }",
      "      // game over -> leaderboard",
      "      if(allDead()){",
      "        const total=(P1.score|0)+(P2.score|0);",
      "        addScore(total);",
      "        const rows=loadLB();",
      "        toastMsg('RUN ENDED. Top: '+(rows[0]?rows[0].s:total),1200);",
      "        paused=true;",
      "      }",
      "    }",
      "    // draw",
      "    const v1=makeView(0, (innerHeight/2)|0, P1);",
      "    const v2=makeView((innerHeight/2)|0, (innerHeight/2)|0, P2);",
      "    updView(v1);updView(v2);",
      "    drawView(v1);",
      "    drawView(v2);",
      "    drawHUD();",
      "    requestAnimationFrame(step);",
      "  }",
      "  // -------- Start --------",
      "  generateLevel();",
      "  toastMsg('Floor 1 — breach initiated',900);",
      "  requestAnimationFrame(step);",
      "})();",
      "</" + "script></body></html>"
    ];
    const GAME_HTML = GAME_LINES.join("\n");

    // Base64 encode to keep shell safe
    const GAME_B64 = btoa(unescape(encodeURIComponent(GAME_HTML)));

    // =======================
    // MENU SHELL (unchanged)
    // =======================
    const SHELL_LINES = [
      "<!doctype html><html><head><meta charset='utf-8'/>",
      "<meta name='viewport' content='width=device-width,initial-scale=1'/>",
      "<title>Launcher</title>",
      "<style>",
      "html,body{margin:0;height:100%;background:#050008;color:#eaeaff;font-family:system-ui,Segoe UI,Roboto,Arial}",
      ".wrap{display:flex;align-items:center;justify-content:center;height:100%}",
      ".card{width:min(760px,92vw);border-radius:18px;padding:18px;background:rgba(255,255,255,.06);box-shadow:0 10px 40px rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08)}",
      "h1{margin:0 0 10px;font-size:22px}",
      ".row{display:flex;gap:10px;flex-wrap:wrap}",
      "button{cursor:pointer;border:0;border-radius:14px;padding:12px 14px;font-weight:650}",
      ".primary{background:#7c5cff;color:#fff}",
      ".ghost{background:rgba(255,255,255,.10);color:#fff}",
      "input{flex:1;min-width:220px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.35);color:#fff;padding:12px 12px}",
      ".small{opacity:.75;font-size:12px;line-height:1.35;margin-top:10px}",
      ".wm{opacity:.25;font-size:12px;margin-top:14px}",
      "</style></head><body>",
      "<div class='wrap'><div class='card'>",
      "<h1>Launcher</h1>",
      "<div class='row'>",
      "<button class='primary' id='play'>Play Neon Rift</button>",
      "<button class='ghost' id='fs'>Fullscreen</button>",
      "</div>",
      "<div style='height:10px'></div>",
      "<div class='row'>",
      "<input id='url' placeholder='Load any URL in this iframe (optional)'/>",
      "<button class='ghost' id='go'>Load URL</button>",
      "</div>",
      "<div class='small'>",
      "• Some sites block embedding in iframes (X-Frame-Options / CSP), so “Load URL” may fail.<br>",
      "• Game always works (local HTML). P1 uses mouse aim; P2 auto-aims.",
      "</div>",
      "<div class='wm'>freegameslist.blog</div>",
      "</div></div>",
      "<script>",
      "var GAME_B64=" + JSON.stringify(GAME_B64) + ";",
      "var pre=" + JSON.stringify(String(prefillUrl || \"\")) + ";",
      "function d64(b){return decodeURIComponent(escape(atob(b)));}",
      "document.getElementById('play').onclick=function(){",
      "  var html=d64(GAME_B64);",
      "  var blob=new Blob([html],{type:'text/html'});",
      "  location.href=URL.createObjectURL(blob);",
      "};",
      "document.getElementById('fs').onclick=function(){document.documentElement.requestFullscreen&&document.documentElement.requestFullscreen();};",
      "document.getElementById('go').onclick=function(){var u=document.getElementById('url').value.trim();if(u)location.href=u;};",
      "if(pre)document.getElementById('url').value=pre;",
      "</" + "script></body></html>"
    ];
    const SHELL = SHELL_LINES.join("\n");

    const doc = iframe.contentWindow.document;
    doc.open();
    doc.write(SHELL);
    doc.close();
  };

  console.log("✅ Neon Rift Cyberpunk build installed. Run create() to open the launcher.");
})();
